#
# downcast - tools for unpacking patient data from DWC
#
# Copyright (c) 2018 Laboratory for Computational Physiology
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import re
from collections import namedtuple
import ply.lex
import ply.yacc

from .exceptions import (ProgrammingError, ParameterCountError)

# This implements a parser for an extremely limited subset of SQL,
# just enough to handle the queries generated by downcast.

SelectStatement = namedtuple('SelectStatement', (
    'columns', 'table', 'constraints', 'order', 'limit'))

Constraint = namedtuple('Constraint', (
    'column', 'relation', 'value'))

class SimpleQueryParser:
    _keywords = {
        'SELECT', 'FROM', 'WHERE', 'AND', 'ORDER', 'BY', 'LIMIT'
    }

    tokens = list(_keywords) + [
        'PARAM', 'LE', 'GE', 'identifier', 'bracketed_identifier',
        'integer', 'string_constant'
    ]

    literals = ['=', '<', '>', ',', '*', ';']

    t_ignore = ' \t\r\f\n'

    t_LE = r'<='
    t_GE = r'>='

    def t_PARAM(self, t):
        r'\?'
        try:
            t.value = next(self._param_iter)
        except StopIteration:
            c = None
            if self._constraint_pos is not None:
                c = self._input[self._constraint_pos:self._lexer.lexpos]
            raise ParameterCountError('not enough parameters for query', c)
        return t

    def t_identifier(self, t):
        r'[A-Za-z_][A-Za-z0-9_.]*'
        u = t.value.upper()
        if u in SimpleQueryParser._keywords:
            t.type = u
        return t

    def t_bracketed_identifier(self, t):
        r'\[[A-Za-z0-9_.]+\]'
        t.value = t.value[1:-1]
        return t

    def t_integer(self, t):
        r'[0-9]+'
        t.value = int(t.value)
        return t

    def t_string_constant(self, t):
        r"'(?:[^']+|'')*'"
        t.value = t.value[1:-1].replace("''", "'")
        return t

    def t_error(self, t):
        text = (self._input[:t.lexpos] + '<<!>>' + self._input[t.lexpos:])
        raise ProgrammingError('syntax error in %r' % text)

    ################################################################

    def p_statement(self, p):
        """
        statement : SELECT columns FROM table constraints order limit ';'
                  | SELECT columns FROM table constraints order limit
        """
        p[0] = SelectStatement(columns = p[2], table = p[4],
                               constraints = p[5], order = p[6],
                               limit = p[7])

    def p_columns(self, p):
        """columns : columns ',' column"""
        p[0] = p[1] + [p[3]]

    def p_columns_1(self, p):
        """columns : column"""
        p[0] = [p[1]]

    def p_columns_star(self, p):
        """columns : '*'"""
        p[0] = ['*']

    def p_column(self, p):
        """column : identifier"""
        p[0] = p[1]
        self._column_pos = p.lexpos(1)

    def p_table(self, p):
        """
        table : identifier
              | bracketed_identifier
        """
        p[0] = p[1]

    def p_constraints(self, p):
        """constraints : WHERE constraint_list"""
        p[0] = p[2]

    def p_constraints_0(self, p):
        """constraints : """
        p[0] = []

    def p_constraint_list(self, p):
        """constraint_list : constraint_list AND constraint"""
        p[0] = p[1] + [p[3]]

    def p_constraint_list_1(self, p):
        """constraint_list : constraint"""
        p[0] = [p[1]]

    def p_constraint(self, p):
        """
        constraint : constraint_column '=' constraint_value
                   | constraint_column '<' constraint_value
                   | constraint_column '>' constraint_value
                   | constraint_column LE constraint_value
                   | constraint_column GE constraint_value
        """
        p[0] = Constraint(column = p[1], relation = p[2], value = p[3])
        self._constraint_pos = None

    def p_constraint_column(self, p):
        """constraint_column : column"""
        p[0] = p[1]
        self._constraint_pos = self._column_pos

    def p_constraint_value(self, p):
        """
        constraint_value : PARAM
                         | integer
                         | string_constant
        """
        p[0] = p[1]

    def p_order(self, p):
        """order : ORDER BY column"""
        p[0] = p[3]

    def p_order_0(self, p):
        """order : """
        p[0] = None

    def p_limit(self, p):
        """limit : LIMIT integer"""
        p[0] = p[2]

    def p_limit_0(self, p):
        """limit : """
        p[0] = None

    def p_error(self, t):
        if t:
            desc = t.type
            text = (self._input[:t.lexpos] + '<<!>>' + self._input[t.lexpos:])
        else:
            desc = 'EOF'
            text = (self._input + '<<!>>')
        raise ProgrammingError('syntax error (unexpected %s) in %r'
                               % (desc, text))

    def __init__(self):
        self._lexer = ply.lex.lex(module = self)
        self._parser = ply.yacc.yacc(module = self,
                                     write_tables = False,
                                     debug = False)

    def parse(self, statement, params):
        self._input = statement
        self._param_iter = iter(params)
        self._constraint_pos = None
        q = self._parser.parse(statement, lexer = self._lexer)
        try:
            next(self._param_iter)
            raise ParameterCountError('too many parameters for query')
        except StopIteration:
            return q
